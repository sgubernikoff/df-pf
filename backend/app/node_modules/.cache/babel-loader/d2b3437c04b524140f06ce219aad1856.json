{"ast":null,"code":"'use client';\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport mergeRefs from 'merge-refs';\nimport invariant from 'tiny-invariant';\nimport warning from 'warning';\nimport * as pdfjs from 'pdfjs-dist';\nimport StructTree from '../StructTree.js';\nimport usePageContext from '../shared/hooks/usePageContext.js';\nimport { cancelRunningTask, getDevicePixelRatio, isCancelException, makePageCallback } from '../shared/utils.js';\nconst ANNOTATION_MODE = pdfjs.AnnotationMode;\nexport default function Canvas(props) {\n  const pageContext = usePageContext();\n  invariant(pageContext, 'Unable to find Page context.');\n  const mergedProps = Object.assign(Object.assign({}, pageContext), props);\n  const _className = mergedProps._className,\n    canvasBackground = mergedProps.canvasBackground,\n    _mergedProps$devicePi = mergedProps.devicePixelRatio,\n    devicePixelRatio = _mergedProps$devicePi === void 0 ? getDevicePixelRatio() : _mergedProps$devicePi,\n    onRenderErrorProps = mergedProps.onRenderError,\n    onRenderSuccessProps = mergedProps.onRenderSuccess,\n    page = mergedProps.page,\n    renderForms = mergedProps.renderForms,\n    renderTextLayer = mergedProps.renderTextLayer,\n    rotate = mergedProps.rotate,\n    scale = mergedProps.scale;\n  const canvasRef = props.canvasRef;\n  invariant(page, 'Attempted to render page canvas, but no page was specified.');\n  const canvasElement = useRef(null);\n  /**\n   * Called when a page is rendered successfully.\n   */\n  function onRenderSuccess() {\n    if (!page) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    if (onRenderSuccessProps) {\n      onRenderSuccessProps(makePageCallback(page, scale));\n    }\n  }\n  /**\n   * Called when a page fails to render.\n   */\n  function onRenderError(error) {\n    if (isCancelException(error)) {\n      return;\n    }\n    warning(false, error.toString());\n    if (onRenderErrorProps) {\n      onRenderErrorProps(error);\n    }\n  }\n  const renderViewport = useMemo(() => page.getViewport({\n    scale: scale * devicePixelRatio,\n    rotation: rotate\n  }), [devicePixelRatio, page, rotate, scale]);\n  const viewport = useMemo(() => page.getViewport({\n    scale,\n    rotation: rotate\n  }), [page, rotate, scale]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Ommitted callbacks so they are not called every time they change\n  useEffect(function drawPageOnCanvas() {\n    if (!page) {\n      return;\n    }\n    // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.\n    page.cleanup();\n    const canvas = canvasElement.current;\n    if (!canvas) {\n      return;\n    }\n    canvas.width = renderViewport.width;\n    canvas.height = renderViewport.height;\n    canvas.style.width = `${Math.floor(viewport.width)}px`;\n    canvas.style.height = `${Math.floor(viewport.height)}px`;\n    canvas.style.visibility = 'hidden';\n    const renderContext = {\n      annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,\n      canvasContext: canvas.getContext('2d', {\n        alpha: false\n      }),\n      viewport: renderViewport\n    };\n    if (canvasBackground) {\n      renderContext.background = canvasBackground;\n    }\n    const cancellable = page.render(renderContext);\n    const runningTask = cancellable;\n    cancellable.promise.then(() => {\n      canvas.style.visibility = '';\n      onRenderSuccess();\n    }).catch(onRenderError);\n    return () => cancelRunningTask(runningTask);\n  }, [canvasBackground, page, renderForms, renderViewport, viewport]);\n  const cleanup = useCallback(() => {\n    const canvas = canvasElement.current;\n    /**\n     * Zeroing the width and height cause most browsers to release graphics\n     * resources immediately, which can greatly reduce memory consumption.\n     */\n    if (canvas) {\n      canvas.width = 0;\n      canvas.height = 0;\n    }\n  }, []);\n  useEffect(() => cleanup, [cleanup]);\n  return _jsx(\"canvas\", {\n    className: `${_className}__canvas`,\n    dir: \"ltr\",\n    ref: mergeRefs(canvasRef, canvasElement),\n    style: {\n      display: 'block',\n      userSelect: 'none'\n    },\n    children: renderTextLayer ? _jsx(StructTree, {}) : null\n  });\n}","map":null,"metadata":{},"sourceType":"module"}