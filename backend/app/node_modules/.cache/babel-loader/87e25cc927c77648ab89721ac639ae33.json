{"ast":null,"code":"'use client';\n\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useRef } from 'react';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport clsx from 'clsx';\nimport mergeRefs from 'merge-refs';\nimport invariant from 'tiny-invariant';\nimport warning from 'warning';\nimport PageContext from './PageContext.js';\nimport Message from './Message.js';\nimport Canvas from './Page/Canvas.js';\nimport TextLayer from './Page/TextLayer.js';\nimport AnnotationLayer from './Page/AnnotationLayer.js';\nimport { cancelRunningTask, isProvided, makePageCallback } from './shared/utils.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nconst defaultScale = 1;\n/**\n * Displays a page.\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function, however some advanced functions like linking between pages inside a document may not be working correctly.\n */\nexport default function Page(props) {\n  const documentContext = useDocumentContext();\n  const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n  const _mergedProps$_classNa = mergedProps._className,\n    _className = _mergedProps$_classNa === void 0 ? 'react-pdf__Page' : _mergedProps$_classNa,\n    _mergedProps$_enableR = mergedProps._enableRegisterUnregisterPage,\n    _enableRegisterUnregisterPage = _mergedProps$_enableR === void 0 ? true : _mergedProps$_enableR,\n    canvasBackground = mergedProps.canvasBackground,\n    canvasRef = mergedProps.canvasRef,\n    children = mergedProps.children,\n    className = mergedProps.className,\n    CustomRenderer = mergedProps.customRenderer,\n    customTextRenderer = mergedProps.customTextRenderer,\n    devicePixelRatio = mergedProps.devicePixelRatio,\n    _mergedProps$error = mergedProps.error,\n    error = _mergedProps$error === void 0 ? 'Failed to load the page.' : _mergedProps$error,\n    height = mergedProps.height,\n    inputRef = mergedProps.inputRef,\n    _mergedProps$loading = mergedProps.loading,\n    loading = _mergedProps$loading === void 0 ? 'Loading pageâ€¦' : _mergedProps$loading,\n    _mergedProps$noData = mergedProps.noData,\n    noData = _mergedProps$noData === void 0 ? 'No page specified.' : _mergedProps$noData,\n    onGetAnnotationsErrorProps = mergedProps.onGetAnnotationsError,\n    onGetAnnotationsSuccessProps = mergedProps.onGetAnnotationsSuccess,\n    onGetStructTreeErrorProps = mergedProps.onGetStructTreeError,\n    onGetStructTreeSuccessProps = mergedProps.onGetStructTreeSuccess,\n    onGetTextErrorProps = mergedProps.onGetTextError,\n    onGetTextSuccessProps = mergedProps.onGetTextSuccess,\n    onLoadErrorProps = mergedProps.onLoadError,\n    onLoadSuccessProps = mergedProps.onLoadSuccess,\n    onRenderAnnotationLayerErrorProps = mergedProps.onRenderAnnotationLayerError,\n    onRenderAnnotationLayerSuccessProps = mergedProps.onRenderAnnotationLayerSuccess,\n    onRenderErrorProps = mergedProps.onRenderError,\n    onRenderSuccessProps = mergedProps.onRenderSuccess,\n    onRenderTextLayerErrorProps = mergedProps.onRenderTextLayerError,\n    onRenderTextLayerSuccessProps = mergedProps.onRenderTextLayerSuccess,\n    pageIndexProps = mergedProps.pageIndex,\n    pageNumberProps = mergedProps.pageNumber,\n    pdf = mergedProps.pdf,\n    registerPage = mergedProps.registerPage,\n    _mergedProps$renderAn = mergedProps.renderAnnotationLayer,\n    renderAnnotationLayerProps = _mergedProps$renderAn === void 0 ? true : _mergedProps$renderAn,\n    _mergedProps$renderFo = mergedProps.renderForms,\n    renderForms = _mergedProps$renderFo === void 0 ? false : _mergedProps$renderFo,\n    _mergedProps$renderMo = mergedProps.renderMode,\n    renderMode = _mergedProps$renderMo === void 0 ? 'canvas' : _mergedProps$renderMo,\n    _mergedProps$renderTe = mergedProps.renderTextLayer,\n    renderTextLayerProps = _mergedProps$renderTe === void 0 ? true : _mergedProps$renderTe,\n    rotateProps = mergedProps.rotate,\n    _mergedProps$scale = mergedProps.scale,\n    scaleProps = _mergedProps$scale === void 0 ? defaultScale : _mergedProps$scale,\n    unregisterPage = mergedProps.unregisterPage,\n    width = mergedProps.width,\n    otherProps = __rest(mergedProps, [\"_className\", \"_enableRegisterUnregisterPage\", \"canvasBackground\", \"canvasRef\", \"children\", \"className\", \"customRenderer\", \"customTextRenderer\", \"devicePixelRatio\", \"error\", \"height\", \"inputRef\", \"loading\", \"noData\", \"onGetAnnotationsError\", \"onGetAnnotationsSuccess\", \"onGetStructTreeError\", \"onGetStructTreeSuccess\", \"onGetTextError\", \"onGetTextSuccess\", \"onLoadError\", \"onLoadSuccess\", \"onRenderAnnotationLayerError\", \"onRenderAnnotationLayerSuccess\", \"onRenderError\", \"onRenderSuccess\", \"onRenderTextLayerError\", \"onRenderTextLayerSuccess\", \"pageIndex\", \"pageNumber\", \"pdf\", \"registerPage\", \"renderAnnotationLayer\", \"renderForms\", \"renderMode\", \"renderTextLayer\", \"rotate\", \"scale\", \"unregisterPage\", \"width\"]);\n  const _useResolver = useResolver(),\n    _useResolver2 = _slicedToArray(_useResolver, 2),\n    pageState = _useResolver2[0],\n    pageDispatch = _useResolver2[1];\n  const page = pageState.value,\n    pageError = pageState.error;\n  const pageElement = useRef(null);\n  invariant(pdf, 'Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.');\n  const pageIndex = isProvided(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;\n  const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : isProvided(pageIndexProps) ? pageIndexProps + 1 : null;\n  const rotate = rotateProps !== null && rotateProps !== void 0 ? rotateProps : page ? page.rotate : null;\n  const scale = useMemo(() => {\n    if (!page) {\n      return null;\n    }\n    // Be default, we'll render page at 100% * scale width.\n    let pageScale = 1;\n    // Passing scale explicitly null would cause the page not to render\n    const scaleWithDefault = scaleProps !== null && scaleProps !== void 0 ? scaleProps : defaultScale;\n    // If width/height is defined, calculate the scale of the page so it could be of desired width.\n    if (width || height) {\n      const viewport = page.getViewport({\n        scale: 1,\n        rotation: rotate\n      });\n      if (width) {\n        pageScale = width / viewport.width;\n      } else if (height) {\n        pageScale = height / viewport.height;\n      }\n    }\n    return scaleWithDefault * pageScale;\n  }, [height, page, rotate, scaleProps, width]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: useEffect intentionally triggered on pdf change\n  useEffect(function hook() {\n    return () => {\n      if (!isProvided(pageIndex)) {\n        // Impossible, but TypeScript doesn't know that\n        return;\n      }\n      if (_enableRegisterUnregisterPage && unregisterPage) {\n        unregisterPage(pageIndex);\n      }\n    };\n  }, [_enableRegisterUnregisterPage, pdf, pageIndex, unregisterPage]);\n  /**\n   * Called when a page is loaded successfully\n   */\n  function onLoadSuccess() {\n    if (onLoadSuccessProps) {\n      if (!page || !scale) {\n        // Impossible, but TypeScript doesn't know that\n        return;\n      }\n      onLoadSuccessProps(makePageCallback(page, scale));\n    }\n    if (_enableRegisterUnregisterPage && registerPage) {\n      if (!isProvided(pageIndex) || !pageElement.current) {\n        // Impossible, but TypeScript doesn't know that\n        return;\n      }\n      registerPage(pageIndex, pageElement.current);\n    }\n  }\n  /**\n   * Called when a page failed to load\n   */\n  function onLoadError() {\n    if (!pageError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, pageError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(pageError);\n    }\n  }\n  // biome-ignore lint/correctness/useExhaustiveDependencies: useEffect intentionally triggered on pdf and pageIndex change\n  useEffect(function resetPage() {\n    pageDispatch({\n      type: 'RESET'\n    });\n  }, [pageDispatch, pdf, pageIndex]);\n  useEffect(function loadPage() {\n    if (!pdf || !pageNumber) {\n      return;\n    }\n    const cancellable = makeCancellable(pdf.getPage(pageNumber));\n    const runningTask = cancellable;\n    cancellable.promise.then(nextPage => {\n      pageDispatch({\n        type: 'RESOLVE',\n        value: nextPage\n      });\n    }).catch(error => {\n      pageDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => cancelRunningTask(runningTask);\n  }, [pageDispatch, pdf, pageNumber]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Ommitted callbacks so they are not called every time they change\n  useEffect(() => {\n    if (page === undefined) {\n      return;\n    }\n    if (page === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  }, [page, scale]);\n  const childContext = useMemo(() =>\n  // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that\n  page && isProvided(pageIndex) && pageNumber && isProvided(rotate) && isProvided(scale) ? {\n    _className,\n    canvasBackground,\n    customTextRenderer,\n    devicePixelRatio,\n    onGetAnnotationsError: onGetAnnotationsErrorProps,\n    onGetAnnotationsSuccess: onGetAnnotationsSuccessProps,\n    onGetStructTreeError: onGetStructTreeErrorProps,\n    onGetStructTreeSuccess: onGetStructTreeSuccessProps,\n    onGetTextError: onGetTextErrorProps,\n    onGetTextSuccess: onGetTextSuccessProps,\n    onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps,\n    onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps,\n    onRenderError: onRenderErrorProps,\n    onRenderSuccess: onRenderSuccessProps,\n    onRenderTextLayerError: onRenderTextLayerErrorProps,\n    onRenderTextLayerSuccess: onRenderTextLayerSuccessProps,\n    page,\n    pageIndex,\n    pageNumber,\n    renderForms,\n    renderTextLayer: renderTextLayerProps,\n    rotate,\n    scale\n  } : null, [_className, canvasBackground, customTextRenderer, devicePixelRatio, onGetAnnotationsErrorProps, onGetAnnotationsSuccessProps, onGetStructTreeErrorProps, onGetStructTreeSuccessProps, onGetTextErrorProps, onGetTextSuccessProps, onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccessProps, onRenderErrorProps, onRenderSuccessProps, onRenderTextLayerErrorProps, onRenderTextLayerSuccessProps, page, pageIndex, pageNumber, renderForms, renderTextLayerProps, rotate, scale]);\n  const eventProps = useMemo(() => makeEventProps(otherProps, () => page ? scale ? makePageCallback(page, scale) : undefined : page),\n  // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME\n  [otherProps, page, scale]);\n  const pageKey = `${pageIndex}@${scale}/${rotate}`;\n  function renderMainLayer() {\n    switch (renderMode) {\n      case 'custom':\n        {\n          invariant(CustomRenderer, `renderMode was set to \"custom\", but no customRenderer was passed.`);\n          return _jsx(CustomRenderer, {}, `${pageKey}_custom`);\n        }\n      case 'none':\n        return null;\n      case 'canvas':\n      default:\n        return _jsx(Canvas, {\n          canvasRef: canvasRef\n        }, `${pageKey}_canvas`);\n    }\n  }\n  function renderTextLayer() {\n    if (!renderTextLayerProps) {\n      return null;\n    }\n    return _jsx(TextLayer, {}, `${pageKey}_text`);\n  }\n  function renderAnnotationLayer() {\n    if (!renderAnnotationLayerProps) {\n      return null;\n    }\n    return _jsx(AnnotationLayer, {}, `${pageKey}_annotations`);\n  }\n  function renderChildren() {\n    return _jsxs(PageContext.Provider, {\n      value: childContext,\n      children: [renderMainLayer(), renderTextLayer(), renderAnnotationLayer(), children]\n    });\n  }\n  function renderContent() {\n    if (!pageNumber) {\n      return _jsx(Message, {\n        type: \"no-data\",\n        children: typeof noData === 'function' ? noData() : noData\n      });\n    }\n    if (pdf === null || page === undefined || page === null) {\n      return _jsx(Message, {\n        type: \"loading\",\n        children: typeof loading === 'function' ? loading() : loading\n      });\n    }\n    if (pdf === false || page === false) {\n      return _jsx(Message, {\n        type: \"error\",\n        children: typeof error === 'function' ? error() : error\n      });\n    }\n    return renderChildren();\n  }\n  return _jsx(\"div\", Object.assign({\n    className: clsx(_className, className),\n    \"data-page-number\": pageNumber,\n    // Assertion is needed for React 18 compatibility\n    ref: mergeRefs(inputRef, pageElement),\n    style: {\n      ['--scale-factor']: `${scale}`,\n      backgroundColor: canvasBackground || 'white',\n      position: 'relative',\n      minWidth: 'min-content',\n      minHeight: 'min-content'\n    }\n  }, eventProps, {\n    children: renderContent()\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}