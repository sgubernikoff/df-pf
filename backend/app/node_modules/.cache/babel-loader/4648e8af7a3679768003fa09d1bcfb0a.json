{"ast":null,"code":"'use client';\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ _regeneratorRuntime = function () { return r; }; var t, r = {}, e = Object.prototype, n = e.hasOwnProperty, o = \"function\" == typeof Symbol ? Symbol : {}, i = o.iterator || \"@@iterator\", a = o.asyncIterator || \"@@asyncIterator\", u = o.toStringTag || \"@@toStringTag\"; function c(t, r, e, n) { return Object.defineProperty(t, r, { value: e, enumerable: !n, configurable: !n, writable: !n }); } try { c({}, \"\"); } catch (t) { c = function (t, r, e) { return t[r] = e; }; } function h(r, e, n, o) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype); return c(a, \"_invoke\", function (r, e, n) { var o = 1; return function (i, a) { if (3 === o) throw Error(\"Generator is already running\"); if (4 === o) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var u = n.delegate; if (u) { var c = d(u, n); if (c) { if (c === f) continue; return c; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (1 === o) throw o = 4, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = 3; var h = s(r, e, n); if (\"normal\" === h.type) { if (o = n.done ? 4 : 2, h.arg === f) continue; return { value: h.arg, done: n.done }; } \"throw\" === h.type && (o = 4, n.method = \"throw\", n.arg = h.arg); } }; }(r, n, new Context(o || [])), !0), a; } function s(t, r, e) { try { return { type: \"normal\", arg: t.call(r, e) }; } catch (t) { return { type: \"throw\", arg: t }; } } r.wrap = h; var f = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var l = {}; c(l, i, function () { return this; }); var p = Object.getPrototypeOf, y = p && p(p(x([]))); y && y !== e && n.call(y, i) && (l = y); var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l); function g(t) { [\"next\", \"throw\", \"return\"].forEach(function (r) { c(t, r, function (t) { return this._invoke(r, t); }); }); } function AsyncIterator(t, r) { function e(o, i, a, u) { var c = s(t[o], t, i); if (\"throw\" !== c.type) { var h = c.arg, f = h.value; return f && \"object\" == typeof f && n.call(f, \"__await\") ? r.resolve(f.__await).then(function (t) { e(\"next\", t, a, u); }, function (t) { e(\"throw\", t, a, u); }) : r.resolve(f).then(function (t) { h.value = t, a(h); }, function (t) { return e(\"throw\", t, a, u); }); } u(c.arg); } var o; c(this, \"_invoke\", function (t, n) { function i() { return new r(function (r, o) { e(t, n, r, o); }); } return o = o ? o.then(i, i) : i(); }, !0); } function d(r, e) { var n = e.method, o = r.i[n]; if (o === t) return e.delegate = null, \"throw\" === n && r.i.return && (e.method = \"return\", e.arg = t, d(r, e), \"throw\" === e.method) || \"return\" !== n && (e.method = \"throw\", e.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), f; var i = s(o, r.i, e.arg); if (\"throw\" === i.type) return e.method = \"throw\", e.arg = i.arg, e.delegate = null, f; var a = i.arg; return a ? a.done ? (e[r.r] = a.value, e.next = r.n, \"return\" !== e.method && (e.method = \"next\", e.arg = t), e.delegate = null, f) : a : (e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, f); } function w(t) { this.tryEntries.push(t); } function m(r) { var e = r[4] || {}; e.type = \"normal\", e.arg = t, r[4] = e; } function Context(t) { this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0); } function x(r) { if (null != r) { var e = r[i]; if (e) return e.call(r); if (\"function\" == typeof r.next) return r; if (!isNaN(r.length)) { var o = -1, a = function e() { for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e; return e.value = t, e.done = !0, e; }; return a.next = a; } } throw new TypeError(typeof r + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, \"constructor\", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), r.isGeneratorFunction = function (t) { var r = \"function\" == typeof t && t.constructor; return !!r && (r === GeneratorFunction || \"GeneratorFunction\" === (r.displayName || r.name)); }, r.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, \"GeneratorFunction\")), t.prototype = Object.create(v), t; }, r.awrap = function (t) { return { __await: t }; }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () { return this; }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(h(t, e, n, o), i); return r.isGeneratorFunction(e) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, g(v), c(v, u, \"Generator\"), c(v, i, function () { return this; }), c(v, \"toString\", function () { return \"[object Generator]\"; }), r.keys = function (t) { var r = Object(t), e = []; for (var n in r) e.unshift(n); return function t() { for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t; return t.done = !0, t; }; }, r.values = x, Context.prototype = { constructor: Context, reset: function (r) { if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) \"t\" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t); }, stop: function () { this.done = !0; var t = this.tryEntries[0][4]; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function (r) { if (this.done) throw r; var e = this; function n(t) { a.type = \"throw\", a.arg = r, e.next = t; } for (var o = e.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i[4], u = this.prev, c = i[1], h = i[2]; if (-1 === i[0]) return n(\"end\"), !1; if (!c && !h) throw Error(\"try statement without catch or finally\"); if (null != i[0] && i[0] <= u) { if (u < c) return this.method = \"next\", this.arg = t, n(c), !0; if (u < h) return n(h), !1; } } }, abrupt: function (t, r) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) { var o = n; break; } } o && (\"break\" === t || \"continue\" === t) && o[0] <= r && r <= o[2] && (o = null); var i = o ? o[4] : {}; return i.type = t, i.arg = r, o ? (this.method = \"next\", this.next = o[2], f) : this.complete(i); }, complete: function (t, r) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && r && (this.next = r), f; }, finish: function (t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[2] === t) return this.complete(e[4], e[3]), m(e), f; } }, catch: function (t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[0] === t) { var n = e[4]; if (\"throw\" === n.type) { var o = n.arg; m(e); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function (r, e, n) { return this.delegate = { i: x(r), r: e, n: n }, \"next\" === this.method && (this.arg = t), f; } }, r; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\nimport makeEventProps from 'make-event-props';\nimport makeCancellable from 'make-cancellable-promise';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'warning';\nimport { dequal } from 'dequal';\nimport * as pdfjs from 'pdfjs-dist';\nimport DocumentContext from './DocumentContext.js';\nimport Message from './Message.js';\nimport LinkService from './LinkService.js';\nimport PasswordResponses from './PasswordResponses.js';\nimport { cancelRunningTask, dataURItoByteString, displayCORSWarning, isArrayBuffer, isBlob, isBrowser, isDataURI, loadFromFile } from './shared/utils.js';\nimport useResolver from './shared/hooks/useResolver.js';\nconst PDFDataRangeTransport = pdfjs.PDFDataRangeTransport;\nconst defaultOnPassword = (callback, reason) => {\n  switch (reason) {\n    case PasswordResponses.NEED_PASSWORD:\n      {\n        const password = prompt('Enter the password to open this PDF file.');\n        callback(password);\n        break;\n      }\n    case PasswordResponses.INCORRECT_PASSWORD:\n      {\n        const password = prompt('Invalid password. Please try again.');\n        callback(password);\n        break;\n      }\n    default:\n  }\n};\nfunction isParameterObject(file) {\n  return typeof file === 'object' && file !== null && ('data' in file || 'range' in file || 'url' in file);\n}\n/**\n * Loads a document passed using `file` prop.\n */\nconst Document = /*#__PURE__*/forwardRef(function Document(_a, ref) {\n  var children = _a.children,\n    className = _a.className,\n    _a$error = _a.error,\n    error = _a$error === void 0 ? 'Failed to load PDF file.' : _a$error,\n    externalLinkRel = _a.externalLinkRel,\n    externalLinkTarget = _a.externalLinkTarget,\n    file = _a.file,\n    inputRef = _a.inputRef,\n    imageResourcesPath = _a.imageResourcesPath,\n    _a$loading = _a.loading,\n    loading = _a$loading === void 0 ? 'Loading PDF…' : _a$loading,\n    _a$noData = _a.noData,\n    noData = _a$noData === void 0 ? 'No PDF file specified.' : _a$noData,\n    onItemClick = _a.onItemClick,\n    onLoadErrorProps = _a.onLoadError,\n    onLoadProgress = _a.onLoadProgress,\n    onLoadSuccessProps = _a.onLoadSuccess,\n    _a$onPassword = _a.onPassword,\n    onPassword = _a$onPassword === void 0 ? defaultOnPassword : _a$onPassword,\n    onSourceErrorProps = _a.onSourceError,\n    onSourceSuccessProps = _a.onSourceSuccess,\n    options = _a.options,\n    renderMode = _a.renderMode,\n    rotate = _a.rotate,\n    otherProps = __rest(_a, [\"children\", \"className\", \"error\", \"externalLinkRel\", \"externalLinkTarget\", \"file\", \"inputRef\", \"imageResourcesPath\", \"loading\", \"noData\", \"onItemClick\", \"onLoadError\", \"onLoadProgress\", \"onLoadSuccess\", \"onPassword\", \"onSourceError\", \"onSourceSuccess\", \"options\", \"renderMode\", \"rotate\"]);\n  const _useResolver = useResolver(),\n    _useResolver2 = _slicedToArray(_useResolver, 2),\n    sourceState = _useResolver2[0],\n    sourceDispatch = _useResolver2[1];\n  const source = sourceState.value,\n    sourceError = sourceState.error;\n  const _useResolver3 = useResolver(),\n    _useResolver4 = _slicedToArray(_useResolver3, 2),\n    pdfState = _useResolver4[0],\n    pdfDispatch = _useResolver4[1];\n  const pdf = pdfState.value,\n    pdfError = pdfState.error;\n  const linkService = useRef(new LinkService());\n  const pages = useRef([]);\n  const prevFile = useRef(undefined);\n  const prevOptions = useRef(undefined);\n  if (file && file !== prevFile.current && isParameterObject(file)) {\n    warning(!dequal(file, prevFile.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to \"file\" prop.`);\n    prevFile.current = file;\n  }\n  // Detect non-memoized changes in options prop\n  if (options && options !== prevOptions.current) {\n    warning(!dequal(options, prevOptions.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to \"options\" prop.`);\n    prevOptions.current = options;\n  }\n  const viewer = useRef({\n    // Handling jumping to internal links target\n    scrollPageIntoView: args => {\n      const dest = args.dest,\n        pageNumber = args.pageNumber,\n        _args$pageIndex = args.pageIndex,\n        pageIndex = _args$pageIndex === void 0 ? pageNumber - 1 : _args$pageIndex;\n      // First, check if custom handling of onItemClick was provided\n      if (onItemClick) {\n        onItemClick({\n          dest,\n          pageIndex,\n          pageNumber\n        });\n        return;\n      }\n      // If not, try to look for target page within the <Document>.\n      const page = pages.current[pageIndex];\n      if (page) {\n        // Scroll to the page automatically\n        page.scrollIntoView();\n        return;\n      }\n      warning(false, `An internal link leading to page ${pageNumber} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);\n    }\n  });\n  useImperativeHandle(ref, () => ({\n    linkService,\n    pages,\n    viewer\n  }), []);\n  /**\n   * Called when a document source is resolved correctly\n   */\n  function onSourceSuccess() {\n    if (onSourceSuccessProps) {\n      onSourceSuccessProps();\n    }\n  }\n  /**\n   * Called when a document source failed to be resolved correctly\n   */\n  function onSourceError() {\n    if (!sourceError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, sourceError.toString());\n    if (onSourceErrorProps) {\n      onSourceErrorProps(sourceError);\n    }\n  }\n  function resetSource() {\n    sourceDispatch({\n      type: 'RESET'\n    });\n  }\n  // biome-ignore lint/correctness/useExhaustiveDependencies: See https://github.com/biomejs/biome/issues/3080\n  useEffect(resetSource, [file, sourceDispatch]);\n  const findDocumentSource = useCallback(() => __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var fileByteString, data, url, otherParams;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (file) {\n            _context.next = 2;\n            break;\n          }\n          return _context.abrupt(\"return\", null);\n        case 2:\n          if (!(typeof file === 'string')) {\n            _context.next = 8;\n            break;\n          }\n          if (!isDataURI(file)) {\n            _context.next = 6;\n            break;\n          }\n          fileByteString = dataURItoByteString(file);\n          return _context.abrupt(\"return\", {\n            data: fileByteString\n          });\n        case 6:\n          displayCORSWarning();\n          return _context.abrupt(\"return\", {\n            url: file\n          });\n        case 8:\n          if (!(file instanceof PDFDataRangeTransport)) {\n            _context.next = 10;\n            break;\n          }\n          return _context.abrupt(\"return\", {\n            range: file\n          });\n        case 10:\n          if (!isArrayBuffer(file)) {\n            _context.next = 12;\n            break;\n          }\n          return _context.abrupt(\"return\", {\n            data: file\n          });\n        case 12:\n          if (!isBrowser) {\n            _context.next = 18;\n            break;\n          }\n          if (!isBlob(file)) {\n            _context.next = 18;\n            break;\n          }\n          _context.next = 16;\n          return loadFromFile(file);\n        case 16:\n          data = _context.sent;\n          return _context.abrupt(\"return\", {\n            data\n          });\n        case 18:\n          // At this point, file must be an object\n          invariant(typeof file === 'object', 'Invalid parameter in file, need either Uint8Array, string or a parameter object');\n          invariant(isParameterObject(file), 'Invalid parameter object: need either .data, .range or .url');\n          // File .url is a string\n          if (!('url' in file && typeof file.url === 'string')) {\n            _context.next = 26;\n            break;\n          }\n          if (!isDataURI(file.url)) {\n            _context.next = 25;\n            break;\n          }\n          url = file.url, otherParams = __rest(file, [\"url\"]);\n          fileByteString = dataURItoByteString(url);\n          return _context.abrupt(\"return\", Object.assign({\n            data: fileByteString\n          }, otherParams));\n        case 25:\n          displayCORSWarning();\n        case 26:\n          return _context.abrupt(\"return\", file);\n        case 27:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  })), [file]);\n  useEffect(() => {\n    const cancellable = makeCancellable(findDocumentSource());\n    cancellable.promise.then(nextSource => {\n      sourceDispatch({\n        type: 'RESOLVE',\n        value: nextSource\n      });\n    }).catch(error => {\n      sourceDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => {\n      cancelRunningTask(cancellable);\n    };\n  }, [findDocumentSource, sourceDispatch]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Ommitted callbacks so they are not called every time they change\n  useEffect(() => {\n    if (typeof source === 'undefined') {\n      return;\n    }\n    if (source === false) {\n      onSourceError();\n      return;\n    }\n    onSourceSuccess();\n  }, [source]);\n  /**\n   * Called when a document is read successfully\n   */\n  function onLoadSuccess() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(pdf);\n    }\n    pages.current = new Array(pdf.numPages);\n    linkService.current.setDocument(pdf);\n  }\n  /**\n   * Called when a document failed to read successfully\n   */\n  function onLoadError() {\n    if (!pdfError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, pdfError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(pdfError);\n    }\n  }\n  // biome-ignore lint/correctness/useExhaustiveDependencies: useEffect intentionally triggered on source change\n  useEffect(function resetDocument() {\n    pdfDispatch({\n      type: 'RESET'\n    });\n  }, [pdfDispatch, source]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Ommitted callbacks so they are not called every time they change\n  useEffect(function loadDocument() {\n    if (!source) {\n      return;\n    }\n    const documentInitParams = options ? Object.assign(Object.assign({}, source), options) : source;\n    const destroyable = pdfjs.getDocument(documentInitParams);\n    if (onLoadProgress) {\n      destroyable.onProgress = onLoadProgress;\n    }\n    if (onPassword) {\n      destroyable.onPassword = onPassword;\n    }\n    const loadingTask = destroyable;\n    const loadingPromise = loadingTask.promise.then(nextPdf => {\n      pdfDispatch({\n        type: 'RESOLVE',\n        value: nextPdf\n      });\n    }).catch(error => {\n      if (loadingTask.destroyed) {\n        return;\n      }\n      pdfDispatch({\n        type: 'REJECT',\n        error\n      });\n    });\n    return () => {\n      loadingPromise.finally(() => loadingTask.destroy());\n    };\n  }, [options, pdfDispatch, source]);\n  // biome-ignore lint/correctness/useExhaustiveDependencies: Ommitted callbacks so they are not called every time they change\n  useEffect(() => {\n    if (typeof pdf === 'undefined') {\n      return;\n    }\n    if (pdf === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  }, [pdf]);\n  useEffect(function setupLinkService() {\n    linkService.current.setViewer(viewer.current);\n    linkService.current.setExternalLinkRel(externalLinkRel);\n    linkService.current.setExternalLinkTarget(externalLinkTarget);\n  }, [externalLinkRel, externalLinkTarget]);\n  const registerPage = useCallback((pageIndex, ref) => {\n    pages.current[pageIndex] = ref;\n  }, []);\n  const unregisterPage = useCallback(pageIndex => {\n    delete pages.current[pageIndex];\n  }, []);\n  const childContext = useMemo(() => ({\n    imageResourcesPath,\n    linkService: linkService.current,\n    onItemClick,\n    pdf,\n    registerPage,\n    renderMode,\n    rotate,\n    unregisterPage\n  }), [imageResourcesPath, onItemClick, pdf, registerPage, renderMode, rotate, unregisterPage]);\n  const eventProps = useMemo(() => makeEventProps(otherProps, () => pdf),\n  // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME\n  [otherProps, pdf]);\n  function renderChildren() {\n    return _jsx(DocumentContext.Provider, {\n      value: childContext,\n      children: children\n    });\n  }\n  function renderContent() {\n    if (!file) {\n      return _jsx(Message, {\n        type: \"no-data\",\n        children: typeof noData === 'function' ? noData() : noData\n      });\n    }\n    if (pdf === undefined || pdf === null) {\n      return _jsx(Message, {\n        type: \"loading\",\n        children: typeof loading === 'function' ? loading() : loading\n      });\n    }\n    if (pdf === false) {\n      return _jsx(Message, {\n        type: \"error\",\n        children: typeof error === 'function' ? error() : error\n      });\n    }\n    return renderChildren();\n  }\n  return _jsx(\"div\", Object.assign({\n    className: clsx('react-pdf__Document', className),\n    // Assertion is needed for React 18 compatibility\n    ref: inputRef,\n    style: {\n      ['--scale-factor']: '1'\n    }\n  }, eventProps, {\n    children: renderContent()\n  }));\n});\nexport default Document;","map":null,"metadata":{},"sourceType":"module"}